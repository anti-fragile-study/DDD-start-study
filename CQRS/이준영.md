# CQRS

## 단일 모델의 단점
단일 모델로 구현할 경우, 조회와 상태변경에서 구현 복잡도가 높아지는 단점이 있다.   
예를들어, 주문 조회를 구현할때 `Order.cancel()` 등의 메소드는 객체지향 관점에서, 데이터를 갖고있는 객체에게 적절한 역할을 부여하는것 같지만, 조회에서는 그렇지 않다.   
주문의 경우 주문 정보를 조회할때, 여러 애그러거트(상품, 가격)등에서 데이터를 읽어와야 하는데, 이는, 길어지는 트랜잭션, 네트워크 호출, I/O 대기로 인한 커넥션 재사용성 저하로 성능 저하로 이어진다.   

## CQRS
이런, 단일 모델의 단점을 다시한번 정리하자면, 아래와 같은 2가지 이유로 단점이 된다.   
1. 조회때, 여러 애그리거트 루트를 조합해야해서 성능저하가 발생한다. (트랜잭션 관점, I/O, 애플리케이션 로직 등. 애플리케이션 로직은 크게 문제되지는 않는 상황이 많은듯)   
2. 수정, 저장등은 보통 하나의 애그리거트 루트에 연산을 진행할때가 많은데, 조회는 여러개의 애그리거트 루트를 포함해야할때가 많다. 즉, 도메인 로직이 복잡해진다.   
   
또한, CQRS를 명시적으로 적용하고있다고 하지 않아도 대규모트래픽을 처리하는 서비스는 CQRS를 처리하고있는경우가 많은데, 예를들어, 조회-명령 모델이 같아도, 조회에서는 반정규화를 통해서 join없이 읽어오게끔 하는등의 구현이 이러한 예시이다.   
만능같은 CQRS여도 장단점은 명확한데, CQRS를 적용한다고 항상 좋은것은 아니며, CQRS를 적용함으로써 늘어나는 코드량, 새롭게 적용해야할수도있는 인프라, 저장공간의 증가등이 단점이 된다. 즉, 트래픽이 충분히 많지 않고, 적은 서비스라면 CQRS는 과한 설계가 될 수 있다.






