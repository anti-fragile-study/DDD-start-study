# 네 개의 영역
아키텍처는 대게 4가지 영역으로 나뉜다.   
- 표현   
  사용자의 요청을 받아, 응용계층이 필요로 하는 데이터로 변경하며, 응용계층의 응답을 다시 클라이언트의 요구에 맞게 변환 응답하는 역할을 담당한다. 대표적으로 스프링 MVC가 표현 계층을 위한 기술중 하나이다.
- 응용   
  애플리케이션 플로우를 담당하며, 도메인 로직을 처리하기보다, 도메인 레이어에 처리를 위임하는 역할을 담당한다.
- 도메인   
  도메인 모델을 구현하며, 도메인 로직이 도메인 레이어에 포함된다.
- 인프라스트럭처   
  DB 접근기술, 메시징 큐 등등 실제 구현 기술이 들어간다.

# 계층 구조 아키텍처
위에 소개된 네 영역을 구성할 때 많이 사용 되는 아키텍처가 아래의 계층형 아키텍처이다.

``` mermaid
flowchart LR

표현 --> 응용
응용 --> 도메인
도메인 --> 인프라스트럭처
```

위 계층형 아키텍처는 `도메인` 레이어가 `인프라스트럭처` 레이어에 강하게 결합된다는 단점이 있다.   
`도메인` 레이어가 `인프라스트럭처` 레이어에 강하게 결합되면, `테스트하기 어려움`, `구현 방식을 변경하기 어려움` 의 문제가 있다. 

# DIP
위의 계층 구조 아키텍처가 갖는 문제점을 DIP 를 통해 해결할 수 있다.

``` mermaid
flowchart LR

Service --> |사용|Repository-Interface
RDBMS-Repository-Impl --> |구현|Repository-Interface

```

위 flowchart를 보면, service는 구체적인 `RDBMS-Repository-Impl` 에 의존하고 있지 않고 추상적인 `Repository-Interface`에 의존하고 있다. 이렇게 함으로써, 구현이 변경되었을때, 주입되는 대상을 변경해주면되고, 테스트가 필요할때 적절히 Stub 객체를 만들면 된다.
   
> [!IMPORTANT]
> 중요한점은, Interface의 위치는 고수준 모델 (더 추상적인 부분) 에 위치해야 된다는 점 이다. 그렇지 않다면, 경계를 가로지르는 선은 `도메인 -> 인프라`로 향하게 되고 여전히 세부사항에 의존적인 코드가 만들어지게 된다.
   
# 도메인 영역의 주요 구성요소
- **ENTITY**    
  고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖으며, 도메인의 고유한 개념을 표현한다.
- **VALUE**   
  개념적인 하나를 표현하며 고유의 식별자를 갖지 않는다.
- **AGGREGATE**   
  Entity와 VALUE를 하나로 묶은것으로 도메인을 이해할때, AGGREGATE 단위로 이해할 수 있도록 도우며, 큰 틀에서 도메인 모델을 관리할 수 있다. 또한, 모든 도메인간 통신을 AGGREGATE 단위로 하게끔 하며, 내부 구현을 감추도록 돕는다.
- **REPOSITORY**   
  도메인 모델의 영속서을 담당한다.
- **DOMAIN SERVICE**
  어떠한 도메인에도 속하지 않은 로직, 여러개의 AGGREGATE가 필요한 로직, 외부 구현을 사용해야하는 로직중, AGGREGATE의 상태를 변경하거나 상태값을 갖고 계산하는 등의 `도메인 특화` 로직이 필요하다면, 도메인 서비스에 위치시킨다.
  
