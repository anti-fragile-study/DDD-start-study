# 애그리거트   

## 애그리거트란?
복잡한 도메인을 이해하고 관리하기 쉬운 상위 수준으로 묶은 방법을 `애그리거트` 라고 한다.   
애그리거트에는 `애그리거트 루트` 라고 하는것이 존재하는데, 다른 애그리거트간 통신에서는 이 `애그리거트 루트`만을 사용하기 때문에, 유지보수성이 증가하고 복잡성이 내려간다.   
   
## 애그리거트 루트란?   
애그리거트 루트는 애그리거트에 속한 다른 엔티티들을 관리하는 애그리거트내 최상위 엔티티이다.   
애그리거트에 속한 모든 객체가 일관된 상태를 유지하게끔 하는 책임을 갖고있으며, 따라서, 서로 다른 애그리거트간 참조는 모두 이 루트를 이용해서 이뤄져야한다.   
또한, 애그리거트 루트에서 같은 애그리거트에 속한 다른 엔티티들을 변경할때, .set(...) 등과 같은 메소드로 변경하는것은 다음과 같은 이유때문에 피하는게 좋다.   
`1. set 이라는 단어는 도메인 규칙을 표현하는데 충분하지 않다.`   
`2. 검증해야할 규칙이 존재할때, setter를 이용한 구현은 로직 중복을 유발한다`   

> [!IMPORTANT]   
> **애그리거트간 트랜잭션과 ID를 이용한 애그리거트 참조**  
> 하나의 트랜잭션에서 여러 애그리거트를 수정하는것은 다음과 같은 이유로 피하는게 좋으며, 하나의 트랜잭션은 하나의 애그리거트에 대해서 연산해야한다.
> 1. 데드락을 유발할 수 있다.    
> 2. 여러개의 테이블을 join하는것은 성능 저하를 발생시킨다.    
> 3. 트랜잭션이 길어질경우 여러 유저의 요청을 동시에 처리하는것에 불리하다.   
> 4. 여러 애그리거트에서 변경이 가능해질경우, 디버깅과 유지보수가 어려워진다.
>     
> 이러한 이유때문에, 서로 다른 애그리거트간 참조는 의도적으로 `간접참조`를 사용한다.
   
## ID를 이용한 애그리거트 참조   
JPA를 사용했을때, 객체 탐색을 통해서 연관된 엔티티를 가져오면 편하게 개발할 수 있다. 하지만, 애그리거트를 직접 참조하는것은 다음 문제를 야기할 수 있다.   
1. **편한 탐색 오용** - 애그리거트를 직접 참조할경우, 다른곳에 속한 애그리거트를 수정하고 싶은 유혹에 빠지기 쉽다.
2. **성능에 대한 고민** - loading 전략을 lazy로 할것인가, eager로 할것인가?
3. **확장 어려움** - 직접 참조를 사용할경우, (추가 구현을 통해서 해결이 가능하긴함) Join 때문에 하나의 데이터베이스 사용이 강제화 된다. 이는 서비스 규모가 커졌을때, 분리된 서버별로 다른 DB를 사용하는것을 어렵게 한다.   
