# 애그리거트 트랜잭션 관리
## 선점 잠금(Pessimistic Lock)
선점잠금은 DBMS 테이블 혹은 칼럼에 락을 획득함으로써 다른 커넥션이 락을 얻지 못하도록 하는 기법이다.   
선점 잠금을 얻음으로써, 갱신 손실문제를 해결할 수 있으며 MySQL, 오라클과 같은 DBMS에서는 `select ... for update` 와 같이 쿼리를 작성함으로써 잠금을 얻을 수 있다.   
   
Spring Data JPA에서는 다음과 같이 `@Lock(LockModeType.PESSIMISTIC_LOCK)` 어노테이션을 통해서 얻을 수 있다.   
``` Java
public interface UserRepository extends JpaRepository<User, Long> {
  @Lock(LockModeType.PESSIMISITC_WRITE)
  Optional<User> findById(Long id)
}
```
   
선점 잠금을 사용할때는 교착상태 (Dead Lock) 이 발생하지 않도록 주의해야한다.   
예를들어, Thread-1 과 Thread-2가 자원 1, 2에 대해서 각각 선점 잠금을 한 뒤에, 반대쪽 자원에 대해서 잠금을 얻으려고 하면, 교착상태에 빠지게 된다.   
따라서, 선점잠금을 사용할때는 사용하는 DBMS가 교착상태를 어떻게 해제하는지 반드시 알아야하며, (MySQL 같은 경우 효율적인 동작을 위해 교착상태에 빠진 트랜잭션중 undo log양이 더 적은 트랜잭션을 롤백 시킨다.) 적당한 대기시간을 설정하는것이 중요하다.   

## 비선점 잠금(Optimisitic Lock)
비선점 잠금은 락을 수행하지않고, 버저닝을 통해서 정합성을 맞추는 기법이다.   
트랜잭션은 커밋단계에서 버전을 한단계 올리게되고, 이때, 자신이 읽어온 데이터와 DB에 저장된 데이터의 버전이 다르다면 트랜잭션을 롤백하는 방식으로 동작한다.   
   
Spring data JPA에서는 `@Entity` 에 `@Version` 을 명시해줌으로써 얻을 수 있다.   
Lock을 얻지 않으므로, 동시 처리량이 올라가서 성능 향상에 도움이 될 수 있지만, 충돌이 잦은 상황에서 사용하면 처리량이 오히려 떨어질 수 있으니 주의해야한다.

## 오프라인 선점 잠금
오프라인 선점잠금은 하나의 요청을 넘어서서 클라이언트의 일련의 행위 시퀀스에 락을 걸어줄 필요가 있을때 사용한다.   
예를들어, 클라이언트가 다음과 같이 동작한다고 가정해보자.
1. 상품 A의 정보를 가져옴.   
2. 상품 A의 가격을 업데이트함.   
   
이때, 클라이언트의 요청은 물리적으로 2개의 요청으로 분리되며, 따라서 쓰레드도 달라지게 된다 즉, spring data jpa 가 제공하는 ThreadLocal 방식으로는 커넥션을 유지하고 있을 수 없다.   
이럴때 사용할 수 있는 방법이 분산 락 기법이다. 분산 락은 사용기술에 따라 여러가지 방식으로 구현될 수 있는데, 아래는 그 예시이다.   

1. MySQL의 NamedLock을 이용해서 구현한다. -> MySQL을 사용하고 있고 추가적인 인프라 구성 필요를 느끼지 못한다면 좋은 방법이다. 하지만, 구현에따라서 미래에 MySQL을 확장하기 어려워질 수 있는 문제가 있을 수 있으니 주의해서 사용해야한다. (ex. DB가 샤딩되어있으면 어디 DB에 NamedLock을 걸고 얻어올것인가?)   
2. Redis 를 사용해서 분산락을 구현한다. -> 가장 자주 봤던 방법이다. 인메모리 데이터베이스에 이벤트 루프 방식으로 속도도 빠르고 자체적으로 HA 구성을 지원하므로 확장도 편하다. 하지만, 추가적인 인프라 구성이 필요하다는 단점이 있다.   

